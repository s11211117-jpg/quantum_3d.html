<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Quantum Core | Responsive</title>
    <style>
        /* --- 基礎設定 --- */
        body { 
            margin: 0; 
            background-color: #000; 
            overflow: hidden; 
            font-family: 'Segoe UI', 'Courier New', monospace; 
            touch-action: none; /* 禁止手機瀏覽器預設縮放 */
        }

        /* --- UI 層 (Flexbox 佈局) --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
            display: flex;
            box-sizing: border-box;
        }

        /* --- 標題與狀態 --- */
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        h1 { 
            color: #fff; margin: 0; font-weight: 200; letter-spacing: 4px; 
            text-transform: uppercase;
        }
        .status { color: #66fcf1; font-size: 0.8rem; margin-top: 5px; opacity: 0.8; }

        /* --- LOG 面板 --- */
        #log-panel {
            position: absolute;
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            text-shadow: 0 0 5px #0f0;
            pointer-events: none;
            white-space: pre-line;
        }

        /* --- 按鈕控制區 --- */
        .controls {
            position: absolute;
            pointer-events: auto;
            display: flex;
            gap: 15px;
        }

        button {
            background: rgba(0, 20, 40, 0.5);
            backdrop-filter: blur(8px);
            border: 1px solid #66fcf1;
            color: #66fcf1;
            font-family: inherit;
            cursor: pointer;
            text-transform: uppercase;
            transition: 0.3s;
            font-weight: bold;
            letter-spacing: 1px;
        }
        button:hover { background: #66fcf1; color: #000; box-shadow: 0 0 20px #66fcf1; }
        button:active { transform: scale(0.95); }

        /* =========================================
           RWD 響應式設計：電腦 vs 手機
           ========================================= */
        
        /* 電腦版樣式 (螢幕寬度 > 768px) */
        @media (min-width: 769px) {
            h1 { font-size: 2rem; }
            
            /* LOG 在右上角 */
            #log-panel {
                top: 30px; right: 30px; text-align: right;
            }

            /* 控制區在右下角，垂直排列 */
            .controls {
                bottom: 40px; right: 40px;
                flex-direction: column;
                width: 200px;
            }
            button { padding: 15px; border-radius: 0 15px 0 15px; }
        }

        /* 手機版樣式 (螢幕寬度 <= 768px) */
        @media (max-width: 768px) {
            h1 { font-size: 1.2rem; letter-spacing: 2px; }
            .info-panel { left: 50%; transform: translateX(-50%); text-align: center; width: 100%; }
            
            /* LOG 移到中間上方，避免擋住 */
            #log-panel {
                top: 80px; left: 50%; transform: translateX(-50%);
                text-align: center;
                width: 100%;
            }

            /* 控制區在底部，水平排列 */
            .controls {
                bottom: 30px; left: 50%; transform: translateX(-50%);
                width: 90%;
                flex-direction: row;
            }
            button { padding: 15px 0; border-radius: 8px; flex: 1; font-size: 14px; }
        }
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #66fcf1; letter-spacing: 2px; animation: blink 1s infinite;
        }
        @keyframes blink { 50% { opacity: 0.3; } }
    </style>
</head>
<body>

    <div id="loading">SYSTEM INITIALIZING...</div>

    <div id="ui-layer">
        <div class="info-panel">
            <h1>Quantum Core</h1>
            <div class="status">SYSTEM: ONLINE | 15mK</div>
        </div>
        
        <div id="log-panel">
            > READY
        </div>

        <div class="controls">
            <button id="btn-view">View (視角)</button>
            <button id="btn-run" style="border-color: #ff0055; color: #ff4477;">Execute (執行)</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
        import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';

        // 全域變數
        let scene, camera, renderer, composer, controls;
        let machineGroup, shellGroup, qpuGroup;
        let qubits = [], pulses = [];
        let isInternalView = false, isRunning = false;
        let isMobile = false;

        const logEl = document.getElementById('log-panel');

        init();
        animate();

        function init() {
            // 1. 偵測裝置
            checkDevice();

            // 2. 場景與相機
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            updateCameraByDevice(); // 根據裝置設定相機初始位置

            // 3. 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: !isMobile }); // 手機關閉反鋸齒以提升效能
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);

            document.getElementById('loading').style.display = 'none';

            // 4. Bloom 特效
            const renderScene = new RenderPass(scene, camera);
            // 手機版降低 Bloom 解析度
            const bloomResolution = isMobile ? new THREE.Vector2(window.innerWidth/2, window.innerHeight/2) : new THREE.Vector2(window.innerWidth, window.innerHeight);
            const bloomPass = new UnrealBloomPass(bloomResolution, 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.15;
            bloomPass.strength = isMobile ? 0.8 : 1.2; // 手機版光暈弱一點
            bloomPass.radius = 0.5;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 5. 燈光
            const ambient = new THREE.AmbientLight(0x333333, 2); 
            scene.add(ambient);
            const mainLight = new THREE.PointLight(0xffd700, 2, 50);
            mainLight.position.set(5, 8, 5);
            scene.add(mainLight);
            const blueFill = new THREE.PointLight(0x0055ff, 2, 40);
            blueFill.position.set(-5, -2, -5);
            scene.add(blueFill);

            // 6. 物件
            createStars();
            createMachine();

            // 7. 控制器
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            controls.target.set(0, -1.5, 0);

            // 8. 事件
            window.addEventListener('resize', onResize);
            document.getElementById('btn-view').addEventListener('click', toggleView);
            document.getElementById('btn-run').addEventListener('click', runSim);
        }

        function checkDevice() {
            isMobile = window.innerWidth <= 768;
        }

        function updateCameraByDevice() {
            if (isMobile) {
                // 手機：退後，視角稍微低一點
                camera.position.set(13, 2, 13);
            } else {
                // 電腦：靠近，俯視角
                camera.position.set(8, 4, 8);
            }
        }

        function createMachine() {
            machineGroup = new THREE.Group();
            
            // 外殼 (Shell)
            shellGroup = new THREE.Group();
            const goldMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, metalness: 0.9, roughness: 0.15, transparent: true, opacity: 1 });
            
            // 結構簡化但保留層次
            const levels = [4, 2, 0, -2];
            levels.forEach((y, i) => {
                const r = 3 - (i * 0.5);
                const plate = new THREE.Mesh(new THREE.CylinderGeometry(r, r, 0.15, 32), goldMat);
                plate.position.y = y;
                shellGroup.add(plate);
                // 連接管
                if (i < levels.length - 1) {
                    const pipes = new THREE.Group();
                    for(let j=0; j<6; j++) {
                        const angle = (j/6) * Math.PI * 2;
                        const pipe = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 2, 8), goldMat);
                        pipe.position.set(Math.cos(angle)*(r-0.5), y-1, Math.sin(angle)*(r-0.5));
                        pipes.add(pipe);
                    }
                    shellGroup.add(pipes);
                }
            });
            
            // 裝飾環
            const ring = new THREE.Mesh(new THREE.TorusGeometry(1.8, 0.05, 8, 64), goldMat);
            ring.rotation.x = Math.PI/2;
            ring.position.y = 0.5;
            shellGroup.add(ring);

            machineGroup.add(shellGroup);

            // 核心 (QPU)
            qpuGroup = new THREE.Group();
            qpuGroup.position.y = -3.5;
            
            const wafer = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.05, 1.5), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            qpuGroup.add(wafer);

            // 5 Qubits
            const positions = [[0,0], [0.5,0.5], [-0.5,0.5], [-0.5,-0.5], [0.5,-0.5]];
            const qGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.2, 16);
            const qMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
            
            positions.forEach(p => {
                const q = new THREE.Mesh(qGeo, qMat.clone());
                q.position.set(p[0], 0.1, p[1]);
                // 光環
                const glow = new THREE.Mesh(new THREE.TorusGeometry(0.12, 0.02, 16, 32), new THREE.MeshBasicMaterial({ color: 0x00ffff }));
                glow.rotation.x = Math.PI/2;
                q.add(glow);
                
                qpuGroup.add(q);
                qubits.push(q);
            });

            machineGroup.add(qpuGroup);
            scene.add(machineGroup);
        }

        function createStars() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<800; i++) {
                pos.push((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ size: 0.1, color: 0x88ccff, transparent: true, opacity: 0.5 });
            scene.add(new THREE.Points(geo, mat));
        }

        function toggleView() {
            isInternalView = !isInternalView;
            if(isInternalView) {
                // 進去
                shellGroup.children.forEach(c => { if(c.material) c.material.opacity = 0.1; shellGroup.children.forEach(g => g.children?.forEach(p => p.material && (p.material.opacity=0.1))); });
                
                // 根據裝置決定鑽進去多深
                const targetY = isMobile ? -1 : -2; 
                const targetDist = isMobile ? 4 : 0;

                moveCam(new THREE.Vector3(0, targetY, 5), new THREE.Vector3(0, -3.5, 0));
                controls.autoRotate = false;
                log("> INTERNAL VIEW");
            } else {
                // 出來
                shellGroup.children.forEach(c => { if(c.material) c.material.opacity = 1; shellGroup.children.forEach(g => g.children?.forEach(p => p.material && (p.material.opacity=1))); });
                
                // 回復原始位置
                const resetPos = isMobile ? new THREE.Vector3(13, 2, 13) : new THREE.Vector3(8, 4, 8);
                moveCam(resetPos, new THREE.Vector3(0, -1.5, 0));
                controls.autoRotate = true;
                log("> EXTERNAL VIEW");
            }
        }

        function moveCam(pos, target) {
            const startP = camera.position.clone();
            const startT = controls.target.clone();
            let t = 0;
            function loop() {
                t += 0.04;
                if(t<=1) {
                    camera.position.lerpVectors(startP, pos, t);
                    controls.target.lerpVectors(startT, target, t);
                    requestAnimationFrame(loop);
                }
            }
            loop();
        }

        function runSim() {
            if(isRunning) return;
            isRunning = true;
            if(!isInternalView) toggleView();

            log("> INITIALIZING...");
            
            setTimeout(() => {
                // 下落脈衝
                qubits.forEach(q => {
                   const start = new THREE.Vector3(q.position.x, 4, q.position.z);
                   // 加上 Group 的位移
                   const realStart = start.add(qpuGroup.position);
                   const realEnd = q.position.clone().add(qpuGroup.position);
                   createPulse(new THREE.Vector3(q.position.x, 2, q.position.z), realEnd, 0xff0055);
                });

                setTimeout(() => {
                    log("> ENTANGLING...");
                    qubits.forEach(q => { q.material.emissive.setHex(0x00ffff); q.material.emissiveIntensity = 2; });

                    setTimeout(() => {
                        log("> RESULT: |01101⟩");
                        qubits.forEach(q => { 
                            q.material.emissive.setHex(0x000000);
                            const wPos = new THREE.Vector3();
                            q.getWorldPosition(wPos);
                            createPulse(wPos, new THREE.Vector3(wPos.x, 5, wPos.z), 0x00ff00);
                        });
                        isRunning = false;
                    }, 1500);
                }, 800);
            }, 800);
        }

        function createPulse(start, end, color) {
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.08), new THREE.MeshBasicMaterial({ color: color }));
            mesh.position.copy(start);
            scene.add(mesh);
            pulses.push({ mesh, start, end, t:0 });
        }

        function log(msg) {
            logEl.innerText = msg + "\n" + logEl.innerText;
        }

        function onResize() {
            checkDevice(); // 重新檢查是否變更裝置模式 (例如旋轉螢幕)
            
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            
            // 如果不在內部視角，根據新尺寸調整相機距離
            if(!isInternalView) updateCameraByDevice();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            // 脈衝動畫
            for(let i=pulses.length-1; i>=0; i--) {
                let p = pulses[i];
                p.t += 0.05;
                p.mesh.position.lerpVectors(p.start, p.end, p.t);
                if(p.t >= 1) { scene.remove(p.mesh); pulses.splice(i,1); }
            }

            composer.render();
        }
    </script>
</body>
</html>
